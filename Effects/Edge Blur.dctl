#line 2

// clang-format off

DEFINE_UI_PARAMS(protected_radius_x, Protected Radius X, DCTLUI_SLIDER_FLOAT, 0.5, 0.001, 1.5, 0.01)
DEFINE_UI_PARAMS(protected_radius_y, Protected Radius Y, DCTLUI_SLIDER_FLOAT, 0.5, 0.001, 1.5, 0.01)
DEFINE_UI_PARAMS(edge_blur_strength, Max Blur Strength, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 20.0, 0.01)
DEFINE_UI_PARAMS(couple_xy, Couple XY, DCTLUI_CHECK_BOX, 1)

DEFINE_UI_PARAMS(draw_curve, Radius vs Strength Curve, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(draw_heat_map, Draw Blur Map, DCTLUI_CHECK_BOX, 0)

// clang-format on

__DEVICE__ float3 sample_color(int2 pos, __TEXTURE__ p_TexR, __TEXTURE__ p_TexG, __TEXTURE__ p_TexB) {
    return make_float3(_tex2D(p_TexR, pos.x, pos.y), _tex2D(p_TexG, pos.x, pos.y), _tex2D(p_TexB, pos.x, pos.y));
}

__DEVICE__ float powi(float x, int exp) {
    float out = 1.0;
    int abs_exp = exp < 0 ? exp * -1 : exp;
    for (int i = 0; i < abs_exp; ++i) {
        out *= x;
    }
    if (exp < 0) {
        out = 1.0 / out;
    }
    return out;
}

__DEVICE__ float mod(float x, float y) {
    if (x < 0) {
        return y + _fmod(x, y);
    } else {
        return _fmod(x, y);
    }
}

__DEVICE__ float powf(float base, float exp) {
    return _copysignf(_powf(_fabs(base), exp), base);
}

__DEVICE__ float smoothstep2(float start, float end, float alpha) {
    // alpha expected to be from 0 to 1.
    // https://www.desmos.com/calculator/pernscu1gx
    alpha = _clampf(alpha, 0.0, 1.0);
    float factor;
    if (alpha < 0.5) {
        factor = 0.5 * powi(alpha * 2.0, 3);
    } else {
        factor = 0.5 * (2.0 - powi(2.0 - (alpha * 2.0), 3));
    }
    return _mix(start, end, factor);
}

__DEVICE__ float convert_gamma_to_reals(float g) {
    // Converts -1 to +1 range to an exponent
    // Essentially what Resolve does with its gamma
    // correction.
    float out;
    if (g <= 0) {
        out = 1.0f + (-4.0f * g);
    } else {
        out = 1.0f / (4.0f * g + 1);
    }
    return out;
}

typedef struct {
        float blur_rad; // radius from center of blur that has zero weight.
} kernel_params_t;

__DEVICE__ kernel_params_t make_kernel_params(float blur_rad) {
    kernel_params_t params;
    params.blur_rad = blur_rad;
    return params;
}

__DEVICE__ kernel_params_t compute_kernel(float2 xy, float2 dimensions, float2 protected_radius, float edge_blur_strength) {
    // normalized_pos is normalized so that left edge is x=-1, right edge is x=1, and it's square coordinates.
    float2 normalized_pos = make_float2(
        ((xy.x / (dimensions.x - 1.0)) - 0.5) * 2.0,
        ((xy.y / (dimensions.y - 1.0)) - 0.5) * 2.0 // dimensions.y / dimensions.x
    );

    float blur_rad = edge_blur_strength * dimensions.x / 2048.0; // max radius in pixels of blur.
    float curr_angle = _atan2f(normalized_pos.y, normalized_pos.x);
    float curr_radius = _hypotf(normalized_pos.x, normalized_pos.y);

    // float protected_radius_threshold = _hypotf(protected_radius.x * _cosf(curr_angle), protected_radius.y * _sinf(curr_angle));
    // float protected_radius_threshold = powi(protected_radius.x * _cosf(curr_angle), 2) + powi(protected_radius.y * _sinf(curr_angle), 2);

    float protected_radius_curr_x = _sqrtf(1.0 / (1.0 / powi(protected_radius.x, 2) + powi(normalized_pos.y / (normalized_pos.x * protected_radius.y), 2)));
    float protected_radius_curr_y = protected_radius_curr_x * normalized_pos.y / normalized_pos.x;
    float protected_radius_threshold = _hypotf(protected_radius_curr_x, protected_radius_curr_y);

    float2 max_blur_ellipse;
    if (protected_radius.x == 0.0 && protected_radius.y == 0.0) {
        float2 temp_protected_radius = make_float2(1.0, 1.0);
        max_blur_ellipse.y = (_hypotf(temp_protected_radius.x, temp_protected_radius.y) / temp_protected_radius.x);
        max_blur_ellipse.x = temp_protected_radius.x / temp_protected_radius.y * max_blur_ellipse.y;
    } else if (protected_radius.x != 0.0) {
        max_blur_ellipse.y = (_hypotf(protected_radius.x, protected_radius.y) / protected_radius.x);
        max_blur_ellipse.x = protected_radius.x / protected_radius.y * max_blur_ellipse.y;
    } else {
        max_blur_ellipse.x = (_hypotf(protected_radius.y, protected_radius.x) / protected_radius.y);
        max_blur_ellipse.y = protected_radius.y / protected_radius.x * max_blur_ellipse.x;
    }

    float max_radius_curr_x = _sqrtf(1.0 / (1.0 / powi(max_blur_ellipse.x, 2) + powi(normalized_pos.y / (normalized_pos.x * max_blur_ellipse.y), 2)));
    float max_radius_curr_y = max_radius_curr_x * normalized_pos.y / normalized_pos.x;
    float max_radius_threshold = _hypotf(max_radius_curr_x, max_radius_curr_y);
    max_radius_threshold = _fmaxf(protected_radius_threshold, max_radius_threshold);

    float curr_factor = _clampf((curr_radius - protected_radius_threshold) / (max_radius_threshold - protected_radius_threshold), 0.0, 1.0);

    return make_kernel_params(
        smoothstep2(0.0, blur_rad, curr_factor)
        // curr_factor
    );
}

__DEVICE__ float blur_kernel(float2 pos_trans, kernel_params_t params) {
    // pos_trans is number of pixels away from the center of the blur. IE curr_pos - center_pos
    float distance = _hypotf(pos_trans.x, pos_trans.y);
    if (distance > params.blur_rad) {
        return 0.0;
    }
    return 1.0;
}

__DEVICE__ float3
blur(int p_Width, int p_Height, int2 center_pos, __TEXTURE__ p_TexR, __TEXTURE__ p_TexG, __TEXTURE__ p_TexB, kernel_params_t params) {
    float3 total_color = make_float3(0.0, 0.0, 0.0);
    float weight = 0.0;
    if (params.blur_rad < 1) {
        return sample_color(center_pos, p_TexR, p_TexG, p_TexB);
    }
    int num_pixels = 0;
    for (int y = -params.blur_rad; y <= params.blur_rad; y++) {
        for (int x = -params.blur_rad; x <= params.blur_rad; x++) {
            int2 runner_pos = center_pos + make_int2(x, y);
            float w = blur_kernel(make_float2(x, y), params);
            if (w == 0.0) {
                continue;
            }
            float3 curr_color = sample_color(runner_pos, p_TexR, p_TexG, p_TexB);

            total_color += curr_color * w;
            weight += w;
            num_pixels++;
        }
    }
    return total_color / weight;
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, __TEXTURE__ p_TexR, __TEXTURE__ p_TexG, __TEXTURE__ p_TexB) {
    int2 curr_pos = make_int2(p_X, p_Y);

    if (couple_xy) {
        protected_radius_y = protected_radius_x;
    }

    kernel_params_t params = compute_kernel(make_float2((float)p_X, (float)p_Y),  make_float2(p_Width, p_Height), make_float2(protected_radius_x, protected_radius_y), edge_blur_strength);
    // return make_float3(params.blur_rad, params.blur_rad, params.blur_rad);

    float3 output_color = blur(p_Width, p_Height, curr_pos, p_TexR, p_TexG, p_TexB, params);

    if (draw_heat_map) {
        return make_float3(params.blur_rad, params.blur_rad, params.blur_rad);
    }

    if (draw_curve) {
        float x = (float)p_X / (float)(p_Width - 1);
        float y = (float)p_Y / (float)(p_Height - 1);
        x = (x * 2.0) - 1.0; // normalize so that middle is zero
        y = 1 - y;
        y = y - 0.5;
        y *= 3.0;

        params = compute_kernel(make_float2((float)p_X, (p_Height - 1.0) / 2.0),  make_float2(p_Width, p_Height), make_float2(protected_radius_x, protected_radius_x), edge_blur_strength / 20.0);

        if (_fabs(y - params.blur_rad) < 0.002) {
            output_color = make_float3(1.0, 1.0, 1.0);
        }
        if (_fabs(x) < 0.002 && mod(y, 0.15) < 0.1) {
            output_color = make_float3(0.5, 0.5, 0.5);
        }
    }

    return output_color;
}