DEFINE_UI_PARAMS(seed, Seed, DCTLUI_SLIDER_INT, 1, 1, 200, 1)
DEFINE_UI_PARAMS(pivot, Pivot, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.01)
DEFINE_UI_PARAMS(toe, Toe, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.01)
DEFINE_UI_PARAMS(shoulder, Shoulder, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.01)
DEFINE_UI_PARAMS(black_point, Black Point, DCTLUI_SLIDER_FLOAT, 0.0, -1.0, 1.0, 0.01)
DEFINE_UI_PARAMS(white_point, White Point, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.01)
DEFINE_UI_PARAMS(pivot_slope, Pivot Slope, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 3.0, 0.01)
DEFINE_UI_PARAMS(show_curve, Show Curve, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(randomize, Randomize, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(ungroup_rgb, Ungroup RGB, DCTLUI_CHECK_BOX, 0)


typedef struct {
    float pivot_x, pivot_y;
    float white_x, white_y;
    float black_x, black_y;
    float toe_x, toe_y;
    float shoulder_x, shoulder_y;
    float black_slope;
    float white_slope;
    float pivot_slope;
} contrast_params_t;


__DEVICE__ float randu(uint* seed) {
    // Returns random number in interval [0, 1)
    uint old_seed = *seed;
    const uint m = (1 << 31) - 1;
    const uint a = 48271;
    uint new_seed = (a * old_seed) % m;
    *seed = new_seed;
    return (((float) new_seed) / (float) m);
}

__DEVICE__ float randu_bi(uint* seed) {
    // Returns random number in interval (-1, +1)
    return randu(seed) * 2.0 - 1.0;
}

__DEVICE__ inline float3 _max3(float3 x, float3 y) {
    float3 output = make_float3(_fmaxf(x.x, y.x), _fmaxf(x.y, y.y), _fmaxf(x.z, y.z));
    return output;
}

__DEVICE__ float linear_interpolate(float x, float x1, float y1, float x2, float y2) {
    float d = (x - x1) / (x2 - x1);
    float out = d * (y2 - y1) + y1;
    return out;
}

__DEVICE__ float point_slope(float x, float x1, float y1, float m1) {
    return (x - x1) * m1 + y1;
}

__DEVICE__ float point_slope_inv(float y, float x1, float y1, float m1) {
    return (y - y1) / m1 + x1;
}

__DEVICE__ float quadratic_interpolate(float x, float x1, float y1, float m1, float x2, float y2, float m2) {
    // Given lines:
    // y = (x - x1) * m1 + y1
    // y = (x - x2) * m2 + y2
    //
    // Computes a quadratic function that intersects with (x1, y1) with slope m1, and then is tangent
    // to line 2.

    float x3, y3;
    x3 = (y2 - y1 + m1 * x1 - m2 * x2) / (m1 - m2);
    y3 = (x3 - x1) * m1 + y1;

    float smoothing;
    smoothing = 0.0;

    float x1p, y1p, x2p, y2p;

    // x1p = (x3 - x1) * smoothing + x1;
    // y1p = (x1p - x1) * m1 + y1;
    x1p = x1;
    y1p = y1;

    float a, b, c;
    a = -1.0 * (m1*m1 - 2*m1*m2 + m2*m2)/(4*(y2 - y1p - m2*x2 + m2*x1p));
    b = (2*m1*y2 - 2*m1*y1p + m1*m1*x1p + m2*m2*x1p - 2*m1*m2*x2)/(2*(y2 - y1p - m2*x2 + m2*x1p));
    c = y1p - (a * x1p*x1p) - b*x1p;
    x2p = (m2 - b) / (2*a);
    y2p = (x2p - x2) * m2 + y2;

    float interp = a*x*x + b*x + c;
    float output;
    if ((x1p <= x2p && x >= x2p) || (x1p >= x2p && x <= x2p)) {
        output = (x - x2) * m2 + y2;
    } else if ((x1p <= x2p && x <= x1p) || (x1p >= x2p && x >= x1p)) {
        output = (x - x1) * m1 + y1;
    } else {
        output = interp;
    }
    return output;
}

__DEVICE__ float render_contrast_simple_quadratic(contrast_params_t* contrast, float x) {
    // piecewise function
    float m1, m2;
    float out;
    if (x < contrast->toe_x) {
        m1 = contrast->black_slope;
        m2 = contrast->pivot_slope;
        out = quadratic_interpolate(x, contrast->toe_x, contrast->toe_y, m2, contrast->black_x, contrast->black_y, m1);
    } else if (contrast->toe_x <= x && x < contrast->shoulder_x) {
        out = linear_interpolate(x, contrast->toe_x, contrast->toe_y, contrast->shoulder_x, contrast->shoulder_y);
    } else if (contrast->shoulder_x <= x) {
        m1 = contrast->pivot_slope;
        m2 = contrast->white_slope;
        out = quadratic_interpolate(x, contrast->shoulder_x, contrast->shoulder_y, m1, contrast->white_x, contrast->white_y, m2);
    }
    return out;
}

__DEVICE__ float render_contrast(contrast_params_t* contrast, float x) {
    return render_contrast_simple_quadratic(contrast, x);
}

__DEVICE__ float3 render_contrast_3ch(contrast_params_t* contrast_r, contrast_params_t* contrast_g, contrast_params_t* contrast_b, float3 c) {
    c.x = render_contrast(contrast_r, c.x);
    c.y = render_contrast(contrast_g, c.y);
    c.z = render_contrast(contrast_b, c.z);
    return c;
}

__DEVICE__ float3 draw_contrast_curve(contrast_params_t* contrast_r, contrast_params_t* contrast_g, contrast_params_t* contrast_b, float x, float y, float3 curr_color) {
    float3 y_val = render_contrast_3ch(contrast_r, contrast_g, contrast_b, make_float3(x, x, x));
    float3 output_color = curr_color;
    float3 diff = make_float3(_fabs(y_val.x - y), _fabs(y_val.y - y), _fabs(y_val.z - y));
    if (diff.x <= 0.002) {
        output_color = _max3(output_color, make_float3(1.0, 0.0, 0.0));
    }
    if (diff.y <= 0.002) {
        output_color = _max3(output_color, make_float3(0.0, 1.0, 0.0));
    }
    if (diff.z <= 0.002) {
        output_color = _max3(output_color, make_float3(0.0, 0.0, 1.0));
    }
    return output_color;
}

__DEVICE__ float3 draw_grid_lines(float x, float y, float3 curr_color) {
    float major_line_x = _fabs(_fmod(x + 0.1, 0.2) - 0.1);
    float minor_line_x = _fabs(_fmod(x + 0.02, 1.0 / 25.0) - 0.02);
    float major_line_y = _fabs(_fmod(y + 0.1, 0.2) - 0.1);
    float minor_line_y = _fabs(_fmod(y + 0.02, 1.0 / 25.0) - 0.02);

    float3 output_color = curr_color;
    if (0 < x && x < 1.0 && 0 < y && y < 1.0 && (major_line_x <= 0.002 || major_line_y <= 0.002)) {
        output_color += 0.1;
    }
    if (0 < x && x < 1.0 && 0 < y && y < 1.0 && (minor_line_x <= 0.001 || minor_line_y <= 0.001)) {
        output_color += 0.05;
    }
    return output_color;
}

__DEVICE__ void randomize_contrast(contrast_params_t* params, uint* seed) {
    params->black_y = randu(seed) * 0.2;
    params->white_y = 1.0 - randu(seed) * 0.3;
    params->pivot_slope = 1.0 + randu_bi(seed) * 0.2;

    params->toe_y = _mix(params->pivot_y, params->black_y, randu(seed) * 0.9);
    params->toe_x = point_slope_inv(params->toe_y, params->pivot_x, params->pivot_y, params->pivot_slope);
    params->shoulder_y = _mix(params->pivot_y, params->white_y, randu(seed) * 0.9);
    params->shoulder_x = point_slope_inv(params->shoulder_y, params->pivot_x, params->pivot_y, params->pivot_slope);

    params->white_slope = 0.5 * (params->white_y - params->shoulder_y) / (params->white_x - params->shoulder_x);
    params->black_slope = 0.5 * (params->black_y - params->toe_y) / (params->black_x - params->toe_x);
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B)
{
    uint state = seed;

    contrast_params_t params;
    params.pivot_x = pivot;
    params.pivot_y = pivot;
    params.black_x = 0.0;
    params.black_y = black_point;
    params.white_x = 1.0;
    params.white_y = white_point;

    params.pivot_slope = pivot_slope;

    params.toe_y = _mix(params.pivot_y, params.black_y, toe);
    params.toe_x = point_slope_inv(params.toe_y, params.pivot_x, params.pivot_y, params.pivot_slope);
    params.shoulder_y = _mix(params.pivot_y, params.white_y, shoulder);
    params.shoulder_x = point_slope_inv(params.shoulder_y, params.pivot_x, params.pivot_y, params.pivot_slope);
    params.white_slope = 0.5 * (params.white_y - params.shoulder_y) / (params.white_x - params.shoulder_x);
    params.black_slope = 0.5 * (params.black_y - params.toe_y) / (params.black_x - params.toe_x);


    contrast_params_t params_r = params;
    contrast_params_t params_g = params;
    contrast_params_t params_b = params;
    if (randomize && ungroup_rgb) {
        randomize_contrast(&params_r, &state);
        randomize_contrast(&params_g, &state);
        randomize_contrast(&params_b, &state);
    } else if (randomize) {
        randomize_contrast(&params_r, &state);
        params_g = params_r;
        params_b = params_r;
    }

    float3 curr_color = make_float3(p_R, p_G, p_B);
    float3 output_color = render_contrast_3ch(&params_r, &params_g, &params_b, curr_color);

    // Drawing grid lines and the contrast curve.
    float x = (float)p_X / p_Width;
    x = (x - 0.5) * p_Width / p_Height + 0.5;
    float y = 1.0 - (float)p_Y / p_Height;
    if (show_curve) {
        float3 curve_line = draw_contrast_curve(&params_r, &params_g, &params_b, x, y, output_color);
        float3 grid_line = draw_grid_lines(x, y, output_color);
        output_color = _max3(curve_line, grid_line);
    }

    return output_color;
}